# üü¢ Longest Subarray with Majority > K

## üîñ Tags

`#prefix-sum` `#monotonic-stack` `#array` `#subarray`

---

## üìå Problem

Find the **longest subarray** where:

```
count(arr[i] > k) > count(arr[i] <= k)
```

---

## üí° Key Reduction

Convert:

```
arr[i] > k   ‚Üí +1  
arr[i] <= k  ‚Üí -1
```

Now problem becomes:

> üî• Longest subarray with **sum > 0**

---

## üß† Why Prefix Sum?

For subarray `(i, j)`:

```
sum(i, j) = prefix[j] - prefix[i]
```

We want:

```
prefix[j] > prefix[i]
```

And maximize `(j - i)`.

---

## üß± Why Monotonic Decreasing Stack?

We store indices where prefix is **strictly decreasing**.

Why?

* Smaller prefix is better start candidate.
* Makes it easier for future prefix[j] to be greater.
* Removes useless indices.

Each index:

* pushed once
* popped once

üëâ O(n)

---

## üîÅ Why Traverse From Right?

We want **maximum length**.

So for each right boundary `j`,
match with earliest valid `i`.

If:

```
prefix[j] > prefix[i]
```

Then update:

```
maxLen = j - i
```

Pop `i` because it won‚Äôt give a longer answer later.

---

## ‚è± Complexity

```
Time:  O(n)
Space: O(n)
```

---

## üíª Code

```java
class Solution {
    public int longestSubarray(int[] arr, int k) {
        int n = arr.length;

        // Convert to +1 / -1 prefix sum
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            int val = arr[i] > k ? 1 : -1;
            prefix[i + 1] = prefix[i] + val;
        }

        // Build decreasing stack of prefix indices
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i <= n; i++) {
            if (stack.isEmpty() || prefix[i] < prefix[stack.peekLast()]) {
                stack.addLast(i);
            }
        }

        // Match from right to maximize length
        int maxLen = 0;
        for (int j = n; j >= 0; j--) {
            while (!stack.isEmpty() && prefix[j] > prefix[stack.peekLast()]) {
                maxLen = Math.max(maxLen, j - stack.removeLast());
            }
        }

        return maxLen;
    }
}
```

---

## üéØ One-Line Memory Trick

> Convert to +1/-1 ‚Üí Find longest positive sum ‚Üí
> Prefix + Decreasing Stack + Reverse Scan.