# ğŸŸ¢ 1356. Sort Integers by Number of 1 Bits

## ğŸ”– Tags

`#bit-manipulation` `#sorting` `#custom-comparator` `#kernighan` `#decorate-sort` `#O(nlogn)`

---

## ğŸ“Œ Problem

Sort integers by:

1. Number of `1`s in binary
2. If tie â†’ smaller number first

---

## ğŸ’¡ Core Concept

Define:

```text
weight(x) = number of set bits in x
```

Sort by:

```text
(weight(x), x)
```

---

## ğŸ§  Counting Set Bits Efficiently

Using **Kernighanâ€™s Algorithm**:

```java
num = num & (num - 1);
```

Each operation removes the **lowest set bit**.

Runs only as many times as there are `1`s.
Efficient: `O(number of set bits)`.

(Or simply use `Integer.bitCount(x)`.)

---

## âš™ï¸ Pattern Used

This is:

```text
Decorate â†’ Sort â†’ Undecorate
```

Also called **Schwartzian Transform**.

Steps:

1. Attach derived value (bit count)
2. Sort using custom comparator
3. Extract original values

---

## â± Complexity

```
Bit counting:  O(n log(maxValue))
Sorting:       O(n log n)
Overall:       O(n log n)
```

Sorting dominates â†’ optimal.

---

## ğŸ’» Clean Optimized Code

```java
class Solution {
    public int[] sortByBits(int[] arr) {
        Integer[] boxed = Arrays.stream(arr).boxed().toArray(Integer[]::new);
        Arrays.sort(boxed, (a,b) -> {
            int bit = Integer.compare(Integer.bitCount(a), Integer.bitCount(b));
            return bit!=0 ? bit : Integer.compare(a,b);
        });
        for(int i=0; i<arr.length; i++){
            arr[i] = boxed[i];
        }
        return arr;
    }
}
```

---

## ğŸ¯ Interview Takeaway

Whenever sorting by:

* Derived property
* Multiple criteria

Think:

```text
Custom Comparator + Derived Key
```

---
